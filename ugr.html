<!DOCTYPE html>
<html>
<head>
<title>Undergraduate Research Projects</title> <link rel="stylesheet"
type="text/css" href="style.css" /> <meta http-equiv="Content-Type"
content="text/html;charset=utf-8" />

<!-- the following tells search engines not to link here. see
     https://yoast.com/prevent-site-being-indexed/ --> <meta name="robots"
     content="noindex,nofollow"/>

</head>
<body>
<div id="wholepage">

<!--#include file="navbar.html" -->

<div class="section">Project ideas</div>

<p><em>These ideas are meant for internal circulation only. Please do not
post!</em></p>

<p>Below are several ideas I have for upcoming research projects. Are you
  interested in taking one of these on? Let's talk!</p>

<p>(If you don't have all the prerequisites yet for an idea you're excited
  about, don't fret. If we have enough time, we can cover the prerequisites on
  the way.)</p>

<ul>
  <li><p><span class="projname">Lightweight existentials</span>. Haskell
  supports
    <em>existential types</em>, allowing users to pack compile-time type-level
    information into a data structure. These are very useful when returning
    values in a richly typed environment, where the type index of the returned
    value cannot be computed. For example, if we wish to support refinement
    types (in the style
    of <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">LiquidHaskell</a>),
    we need to make refined return types to be existential.</p>

    <p>However, current support for existentials is clunky. Each existential
      requires a separate datatype definition, and existential packing and
      unpacking require explicit pattern matches. Existentials also require an
      extra box at runtime, because
      <tt>newtype</tt>s cannot pack an existential variable. This is all very
      dissatisfying. Instead, existentials should be lightweight, both at
      compile time and at runtime. The question is, how?</p>

    <p>This is a major research project, probably spanning multiple years and
      producing hopefully a number of papers.</p>

    <p><em>Prerequisites:</em> Type-level programming experience in Haskell,
      type theory including existential types, an understanding of Haskell's
      OutsideIn type inference algorithm (or other relevant type inference
      experience).</p></li>

  <li><p><span class="projname">Introspective Template Haskell</span>. This
	  project idea is well described in
	  this <a href="https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/Introspective">wiki
	  page</a>. In summary, the idea is to redesign Haskell's
	  metaprogramming facility to use GHC's internal structures, instead
	  of the current design of using a separate set of language
	  representation types. This work may lead to a paper publishable
	  at <a href="https://www.haskell.org/haskell-symposium/"> Haskell
	  Symposium</a>.</p>

    <p><em>Prerequisites:</em> A semester (or equivalent) of Haskell
      programming, and a knowledge of abstract syntax trees. Experience with
      macro systems is a plus.</p></li>
    
  <li><p><span class="projname">First-class patterns</span>. Haskell supports
      first-class functions, allowing us to abstract arbitrarily over
      functions and writing functions on functions. With
      its <a href="papers/2016/patsyns/pattern-synonyms.pdf">Pattern
      Synonyms</a> feature, Haskell also supports user-defined pattern
      synonyms, allowing some level of abstraction over patterns. But these
      pattern synonyms are not first-class: they must be at top-level, and
      there is no way to bind a variable to be a pattern. This significant
      reseach project would explore the utility and techniques to design a
      programming language with first-class patterns, allowing arbitrary
      pattern abstraction.</p>

    <p>I would expect that a full treatment of this topic would lead to a
    strong ICFP submission.</p>

    <p><em>Prerequisites:</em> A semester of programming in a typed functional
      language and knowledge of type theory.</p></li>

  <li><p><span class="projname">A mechanized proof of Haskell's type
      safety</span>. There are many papers on Haskell's type system. Yet, none
      of them prove safety in a theorem prover. This project would be to write
      a mechanized proof of the type safety of System FC. This is not for the
      light of heart, but it would be great fun, using
      the <a href="https://coq.inria.fr/">best video game ever created</a>,
      or, perhaps another <a href="https://isabelle.in.tum.de/"> proof
      assistant</a> if you already are experienced in it.</p>

    <p>This work would surely lead to a journal-length article.</p>

    <p><em>Prerequisites:</em> A knowledge of type theory, and experience in a
      theorem prover. A knowledge of Haskell is <em>not</em>
      required.</p></li>
      
	  
  <li><p><span class="projname">An analysis of GHC's solver</span>. GHC uses
      an intricate algorithm in order to prove the typability (or lack
      thereof) of Haskell programs. The last textual description of this
      solver was
      in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf">2010</a>,
      and it is now sorely out-of-date. This work would be to analyze the
      current solver, describe the algorithm, and prove that it is
      terminating. It is quite likely <em>not</em> currently a terminating
      algorithm, so part of the work would be repairing it.</p>

    <p>This work, if done well, should lead to either an ICFP publication or
      perhaps a Journal of Functional Programming article.</p>

    <p><em>Prerequisites:</em> Strong Haskell programming skills, as well as
      experience in algorithm analysis and termination proofs.</p></li>

  <li><p><span class="projname">A theory of error messages</span>. Currently,
      type errors are produced at the convenience of GHC. But we can do
      better, doing analysis of how, exactly, the user must fix her program to
      eliminate the type error. In addition, what information would be most
      useful to users when presenting the type error? What can help beginners
      advance? (Some thoughts here are in
      <a href="http://eric.seidel.io/pub/nanomaly-icfp16.pdf">this
      paper</a>.)</p>

    <p>This work would include coming up with a theory of error messages, in
      order to guide GHC's (and other compilers') implementations. A part of
      this work would likely be implementing the idea, and possibly a user
      study. Some inspiration comes from Idris, as
      explained <a href="https://www.youtube.com/watch?v=m7BBCcIDXSg">here</a>.
      Depending on our scope, this could lead to a Haskell Symposium
      publication or perhaps something larger.</p>

    <p><em>Prerequisites:</em> A semester of Haskell programming.</p></li>

  <li><p><span class="projname">Eliminating <tt>TypeRep</tt></span>.
      Currently, GHC has a type <tt>TypeRep</tt> which serves as a runtime
      type representation.
      <tt>TypeRep</tt> is most recently
      described <a href="http://cs.brynmawr.edu/~rae/papers/2016/dynamic/dynamic.pdf">here</a>.
      However, GHC has a perfectly good type that should do this
      already: <tt>Type</tt> (a.k.a. <tt>*</tt>). The problem is
      that <tt>Type</tt> is at the type level and <tt>TypeRep</tt> is at the
      term level.</p>

    <p>This project would be to implement a treatment of <tt>Type</tt> at the
      term level, supplanting <tt>TypeRep</tt>. It is unclear what the
      ramifications of this idea are, and where the discoveries might
      lead.</p>

    <p><em>Prerequisites:</em> Excellent Haskell programming skills, and a
      delight in tinkering with type system esoterica.</p></li>

  <li><p><span class="projname">Semantics for type families</span>. Haskell
      supports <em>type families</em>, which are essentially functions on
      types. But GHC gives no precise semantics for how these behave. This
      project would be to design a semantics (preferably, lazy semantics that
      mirrors term-level behavior) and implement these, demonstrating that the
      semantics can be implemented efficiently.</p>

    <p>This project is likely quite a bit subtler than it seems, possibly
      leading to several publications.</p>

    <p><em>Prerequisites:</em> Excellent Haskell programming skills, and
      experience with type theory and operational semantics.</p></li>

  <li><p><span class="projname">Type inference for generalized algebraic
      datatypes</span>. The state-of-the-art in practical GADT type inference
      still appears to
      be <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf">OutsideIn</a>.
      This paper describes GHC's type inference algorithm, and it sets out a
      specification for this algorithm. However, the implementation does not
      quite meet the specification (see Section 6.3 of that paper). The goal
      of this project would be to come up with a way to phrase GADT type
      inference that leads to an implementable specification.</p>

    <p>A proper job here would lead to a very strong publication, probably for
    POPL.</p>

    <p><em>Prerequisites:</em> Comfort programming with GADTs (preferably in
      Haskell, but Agda / Idris would work, too); strong grasp of type
      inference specifications in the style of Damas-Milner/Cle&#769;ment et
      al. as
      explored <a href="http://cs.brynmawr.edu/~rae/papers/2016/type-app/visible-type-app.pdf">here</a>.</p>
  </li>

  <li><p><span class="projname">Visible type patterns</span>.
	Some <a href="http://cs.brynmawr.edu/~rae/papers/2016/type-app/visible-type-app.pdf">
	recent work</a> has introduced type applications to Haskell. These
	type applications can be used only in expressions, never in patterns.
	Users are thus asking to extend the new feature to patterns, as
	tracked
	in <a href="https://ghc.haskell.org/trac/ghc/ticket/11350">this
	ticket</a>. (Do also
	see <a href="https://ghc.haskell.org/trac/ghc/ticket/11638#comment:1">this
	comment</a>, which discusses some of the challenges.) This project
	would be to specify and implement the new feature, hopefully leading
	to a Haskell Symposium publication.</p>

      <p><em>Prerequisites:</em> Experience with type-level and GADT
      programming in Haskell, and strong Haskell programming skills.</p> </li>

  <li><p><span class="projname">Open data kinds</span>. It is sometimes
      necessary to define new datatypes not to store data, but to use as
      symbols in type-level computation. However, all datatype declarations
      must have a kind that ends in <tt>Type</tt>. This project is to design
      and implement a way of adding new open kinds to GHC. This feature
      request is tracked
      on <a href="https://ghc.haskell.org/trac/ghc/ticket/11080">this
      ticket</a>.
    </p>

    <p>Done well, this work could lead to a Haskell Symposium submission.</p>

    <p><em>Prerequisites:</em> Experience with type-level programming in
    Haskell, and strong Haskell programming skills.</p>
  </li>

  <li><p><span class="projname">Rewriting <tt>deriving</tt> to use Template
      Haskell</span>. GHC's current <tt>deriving</tt> mechanism allows the
      compiler to write class instances on behalf of users. However, there is
      no way for users to extend this useful feature; instead, the
      way <tt>deriving</tt> works is baked into the compiler itself. This
      project would be to design and implement a
      user-extensible <tt>deriving</tt> mechanism via Template Haskell.</p>

    <p><em>Prequisites:</em> Strong Haskell programming skills.</p>
  </li>

  <li><p><span class="projname">Merging GHC's term-level and type-level
      parsers</span>. Part of the work to add dependent types to Haskell is to
      take GHC's current term-level and type-level parsers and merge them
      together, into one parser to rule them all. This work would be a
      concrete step toward building dependent types in a practical
      language.</p>

    <p><em>Prerequisites:</em> A solid knowledge of the Haskell programming
  language, and experience working with declarative parsers.</p></li>

  <li><p><span class="projname">Instance templates</span>. It is often the
      case that instances of several classes belong together. For example, you
      would never have an <tt>Ord</tt> instance for a class without
      an <tt>Eq</tt> instance. Even worse, it's possible to write
      the <tt>Eq</tt> instance directly from information in the <tt>Ord</tt>
      instance. Thus, writing the <tt>Eq</tt> instance is redundant. This
      project is to finish the design and implementation
      of <a href="https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates">instance
      templates</a>, a feature that would allow users to omit the <tt>Eq</tt>
      instance. A well-articulated discussion behind the design and
      implementation of this feature could make for an interesting Haskell
      Symposium submission.</p>

  <p><em>Prerequisites:</em> Strong Haskell programming skills.</p></li>

  <li><p><span class="projname">Detect scoped type variables</span>. Most GHC
      language extensions can be suggested easily by the compiler. Write a
      type family without <tt>TypeFamilies</tt> turned on? You get a nice
      reminder to do so. A notable exception to this
      is <tt>ScopedTypeVariables</tt>, which is never suggested. This project
      would be to come up with a specification for when to suggest this
      extension and then to implement the specification. This may be harder
      than it looks; if so, expect a Haskell Symposium paper to come out of
      this work.</p>

  <p><em>Prerequisites:</em> Strong Haskell programming skills, including work
    with fancy types in Haskell.</p></li>

  <li><p><span class="projname">Unsaturated type families</span>. Every use of
      a type family in Haskell must be fully saturated -- that is, applied to
      all of its declared arguments. This is in contrast to term-level functions,
      which are curried. There is a good reason for the restriction: any other
      approach would cripple type inference. But my <a href="papers/2016/thesis/eisenberg-thesis.pdf">thesis</a> provides a tantalizing way forward. See Section 4.2.4. This project
      would be to flesh out the ideas there, design a concrete language change,
      and implement the change.</p>

    <p>This would likely make a great Haskell Symposium submission. For a student
      with a knowledge of type inference, this could go quite a bit further and
      become an ICFP or POPL submission. I know of no results around type inference
      in the presence of unsaturated type-level functions, so this would be new
      territory for programming language theory.</p>
				      
    <p><em>Prerequisites:</em> Strong Haskell programming skills, including a
      knowledge of type families.</p></li>
      

  <li><p><span class="projname">Other GHC development</span>. There's always
      lots of work to be done improving GHC. For
      example, <a href="https://github.com/ghc-proposals/ghc-proposals">this
      repo</a> and its pull requests track new features proposed for GHC. You
      could implement one! Or there are many bugs out there that need to be
      squashed; you might
      find <a href="https://ghc.haskell.org/trac/ghc/wiki/Newcomers">this
      page</a> helpful.</p>

    <p>Do not consider this to be "just programming". Two minor GHC
      improvements that I started working on, thinking that the challenge was
      just some programming, lead
      to <a href="http://cs.brynmawr.edu/~rae/papers/2014/axioms/axioms.pdf">two</a>
      <a href="http://cs.brynmawr.edu/~rae/papers/2016/type-app/visible-type-app.pdf">papers</a>
      published in top venues. You never know where a problem will lead.</p>

    <p>Possible ideas (more notes to self than anything else):
      <ul>
	<li><a href="https://ghc.haskell.org/trac/ghc/ticket/8177">#8177</a>: Roles for type families</li>
	<li>Untie the knot using <tt>TcTyCon</tt>. (Could relate to a new paper on kind inference for datatypes.)</li>
	<li><a href="https://ghc.haskell.org/trac/ghc/ticket/11307">#11307</a> might be a good warmup. It's a straightforward AST refactoring.</li>
      </ul>
    </p>

	  

    <p><em>Prerequisites:</em> A strong knowledge of the Haskell language,
    along with strong Haskell programming skills.</p>
  </li>
</ul>

The following entries are out-of-date, but are kept here for archival purposes.

<ul>
    <li><p><span class="projname">Implication constraints</span>. Haskell allows
      you to write constraints on types, such as in <tt>Eq a => a -> [a] ->
      Bool</tt>. But it does not allow these constraints to involve
      <em>implications</em>. For example, we might want to say <tt>forall a.
      (forall b. C a b => D b) => a -> a</tt>, which would be valid for
      any <tt>a</tt> such that a <tt>C a b</tt> instance implies the existence
      of a <tt>D b</tt> instance. This feature has been wanted for some time,
      originally
      <a href="https://ghc.haskell.org/trac/ghc/ticket/2256">posted</a> in
      2008. This idea has gained new currency recently, as implication
      contraints would allow GHC to put <tt>join</tt> in the
      <tt>Monad</tt> type class. This project would be to specify and
      implement this extension, quite likely leading to an ICFP
      submission.</p>

    <p><em>Prerequisites:</em> Strong Haskell programming skills, and an
      enjoyment of type-level conundrums.</p>

    <p>This seems to have been done: <a href="https://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/haskell2017b.pdf">Quantified Class Constraints</a>. Gert-Jan Botty, Georgios Karachalias, Tom Schrijvers, Bruno Oliveira and Philip Wadler. Haskell Symposium, 2017.</p>
  </li>
</ul>

</div>
</body>
</html>

    
      

    
    
