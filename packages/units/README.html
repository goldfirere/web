<!DOCTYPE html>
<html>
<head>
<title>units Package README</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<div id="wholepage">

<h1>units</h1>

<p>The <em>units</em> package provides a mechanism for compile-time dimensional analysis
in Haskell programs. It defines an embedded type system based on
units-of-measure. The units defined are fully extensible, and need not relate
to physical properties. In fact, the core package defines only one built-in
unit: Scalar. The package supports defining multiple inter-convertible units,
such as Meter and Foot. When extracting a number from a dimensioned quantity,
the desired unit must be specified, and the value is converted into that unit.</p>

<p>Limitations:
- The <em>units</em> package does not easily allow users to write code polymorphic
  in the chosen units. For example, a <code>sum</code> function that adds together a
  homogeneous list of dimensioned quantities is not straightforward. The
  package exports its internals to allow clients to try to get these working,
  but it is generally hard to do. However, monomorphic functions are easy.</p>

<ul>
<li>The <em>units</em> package is not generalized over number representation: it forces
client code to use <code>Double</code>. It wouldn't be hard to generalize, though, but
it would add a fair amount of extra cruft here and there. Shout (to
<code>eir@cis.upenn.edu</code>) if this is important to you.</li>
</ul>

<h2>User contributions</h2>

<p>It is easy to imagine any number of built-in facilities that would go well
with this package (sets of definitions of units for various systems, vector
operations, a suite of polymorphic functions that are commonly needed but hard
to define, etc.). Yet, I (Richard) don't have the time to imagine or write all
of these. If you write code that is sufficiently general and might want to be
included with this package (but you don't necessarily want to create your own
new package), please write me!</p>

<h2>Modules</h2>

<p>The <em>units</em> package exports several modules. For any given project, you will
include some set of these modules. There are dependency relationships
between them. Of course, you're welcome to <code>import</code> a module without its
dependents, but it probably won't be very useful to you. I hope that this list
grows over time.</p>

<ul>
<li><p><strong><code>Data.Dimensions</code></strong></p>

<p>This is the main exported module. It exports all the necessary functionality
for you to build your own set of units and operate with them. All modules
implicitly depend on this one.</p></li>
<li><p><strong><code>Data.Dimensions.Show</code></strong></p>

<p>This module defines a <code>Show</code> instance for dimensioned quantities, printing
out the number stored along with its canonical dimension. This behavior
may not be the best for every setting, so it is exported separately.</p></li>
<li><p><strong><code>Data.Dimensions.SI</code></strong></p>

<p>This module exports unit definitions for the <a href="http://en.wikipedia.org/wiki/International_System_of_Units">SI</a> system of units.</p></li>
<li><p><strong><code>Data.Dimensions.SI.Prefixes</code></strong></p>

<p>This module exports the SI prefixes. Note that this does <em>not</em> depend
on <code>Data.Dimensions.SI</code> -- you can use these prefixes with any system of
units.</p></li>
<li><p><strong><code>Data.Dimensions.SI.Types</code></strong></p>

<p>This module exports several useful types for use with the SI package,
which it depends on. For example, <code>Length</code> is the type of dimensioned
quantities made with <code>Meter</code>s.</p></li>
</ul>

<h1>Examples</h1>

<h2>Unit definitions</h2>

<p>Here is how to define two inter-convertible units:</p>

<pre><code>data Meter = Meter    -- each unit is a datatype that acts as its own proxy
instance Unit Meter where           -- declare Meter as a Unit
  type BaseUnit Meter = Canonical   -- Meters are "canonical"
instance Show Meter where           -- Show instances are optional but useful
  show _ = "m"                      -- do *not* examine the argument!

data Foot = Foot
instance Unit Foot where
  type BaseUnit Foot = Meter        -- Foot is defined in terms of Meter
  conversionRatio _ = 0.3048        -- do *not* examine the argument!
instance Show Foot where
  show _ = "ft"

type Length = MkDim Meter           -- we will manipulate Lengths
type Length' = MkDim Foot           -- this is the *same* as Length

extend :: Length -&gt; Length          -- a function over lengths
extend x = dim $ x .+ (1 % Meter)   -- more on this later

inMeters :: Length -&gt; Double        -- extract the # of meters
inMeters = (# Meter)                -- more on this later
</code></pre>

<p>Let's pick this apart. The <code>data Meter = Meter</code> declaration creates both the
type <code>Meter</code> and a term-level proxy for it. It would be possible to get away
without the proxies and lots of type annotations, but who would want to?
Then, we define an instance of <code>Unit</code> to make <code>Meter</code> into a proper unit.
The <code>Unit</code> class is primarily responsible for handling unit conversions.
In the case of <code>Meter</code>, we define that as the <em>canonical</em> unit of length, meaning
that all lengths will internally be stored in meters. It also means that we
don't need to define a conversion ratio for meters.</p>

<p>We also include a <code>Show</code> instance for <code>Meter</code> so that lengths can be printed
easily. If you don't need to <code>show</code> your lengths, there is no need for this
instance.</p>

<p>When defining <code>Foot</code>, we say that its <code>BaseUnit</code> is <code>Meter</code>, meaning that
<code>Foot</code> is inter-convertible with <code>Meter</code>. We also must define the conversion
ratio, which is the number of meters in a foot. Note that the
<code>conversionRatio</code> method must take a parameter to fix its type parameter, but
it <em>must not</em> inspect that parameter. Internally, it will be passed
<code>undefined</code> quite often.</p>

<p>The <code>MkDim</code> type synonym makes a dimensioned quantity for a given unit. Note
that <code>Length</code> and <code>Length'</code> are <em>the same type</em>. The <code>MkDim</code> machinery notices
that these two are inter-convertible and will produce the same dimensioned
quantity.</p>

<p>Note that, as you can see in the function examples at the end, it is necessary
to specify the choice of unit when creating a dimensioned quantity or
extracting from a dimensioned quantity. Thus, other than thinking about the
vagaries of floating point wibbles and the <code>Show</code> instance, it is <em>completely
irrelevant</em> which unit is canonical. The type <code>Length</code> defined here could be
used equally well in a program that deals exclusively in feet as it could in a
program with meters.</p>

<p>As a tangential note: I have experimented both with definitions like <code>data
Meter = Meter</code> and <code>data Meter = Meters</code> (note the <code>s</code> at the end). The second
often flows more nicely in code, but the annoyance of having to remember
whether I was at the type level or the term level led me to use the former in
my work.</p>

<h2>Prefixes</h2>

<p>Here is how to define the "kilo" prefix:</p>

<pre><code>data Kilo = Kilo
instance UnitPrefix Kilo where
  multiplier _ = 1000

kilo :: unit -&gt; Kilo :@ unit
kilo = (Kilo :@)
</code></pre>

<p>We define a prefix in much the same way as an ordinary unit, with a datatype
and a constructor to serve as a proxy. Instead of the <code>Unit</code> class, though,
we use the <code>UnitPrefix</code> class, which contains a <code>multiplier</code> method. As with
other methods, this may <em>not</em> inspect its argument.</p>

<p>Due to the way units are encoded, it is necessary to explicitly apply prefixes
with the <code>:@</code> combinator (available at both the type and term level). It is often
convenient to then define a function like <code>kilo</code> to make the code flow more
naturally:</p>

<pre><code>longWayAway :: Length
longWayAway = 150 % kilo Meter

longWayAwayInMeters :: Double
longWayAwayInMeters = longWayAway # Meter  -- 150000.0
</code></pre>

<h2>Unit combinators</h2>

<p>There are several ways of combining units to create other units. Let's also
have a unit of time:</p>

<pre><code>data Second = Second
instance Unit Second where
  type BaseUnit Second = Canonical
instance Show Second where
  show _ = "s"

type Time = MkDim Second
</code></pre>

<p>Units can be multiplied and divided with the operators <code>:*</code> and <code>:/</code>, at either
the term or type level. For example:</p>

<pre><code>type MetersPerSecond = Meter :/ Second
type Velocity1 = MkDim MetersPerSecond

speed :: Velocity1
speed = 20 % (Meter :/ Second)
</code></pre>

<p>The <em>units</em> package also provides combinators "%*" and "%/" to combine the
types of dimensioned quantities.</p>

<pre><code>type Velocity2 = Length %/ Time    -- same type as Velocity1
</code></pre>

<p>There are also exponentiation combinators <code>:^</code> (for units) and <code>%^</code> (for
dimensioned quantities) to raise to a power. To represent the power, the
<em>units</em> package exports <code>Zero</code>, positive numbers <code>One</code> through <code>Five</code>, and
negative numbers <code>MOne</code> through <code>MFive</code>. At the term level, precede the number
with a <code>p</code> (mnemonic: "power"). For example:</p>

<pre><code>type MetersSquared = Meter :^ Two
type Area1 = MkDim MetersSquared
type Area2 = Length %^ Two        -- same type as Area1

roomSize :: Area1
roomSize = 100 % (Meter :^ pTwo)

roomSize' :: Area1
roomSize' = 100 % (Meter :* Meter)
</code></pre>

<p>These operations have no defined inverses, though I don't think they would be
hard to define. Shout if you need that functionality.</p>

<p>Note that addition and subtraction on units does not make physical sense, so
those operations are not provided.</p>

<h2>Dimension-safe cast</h2>

<p>The haddock documentation shows the term-level dimensioned quantity
combinators. The only one deserving special mention is <code>dim</code>, the
dimension-safe cast operator. Expressions written with the <em>units</em> package can
have their types inferred. This works just fine in practice, but the types are
terrible, unfortunately. Much better is to use top-level annotations (using
abbreviations like <code>Length</code> and <code>Time</code>) for your functions. However, it may
happen that the inferred type of your expression and the given type of your
function may not exactly match up. This is because dimensioned quantities have
a looser notion of type equality than Haskell does. For example, "meter *
second" should be the same as "second * meter", even those these are in
different order. The <code>dim</code> function checks (at compile time) to make sure its
input type and output type represent the same underlying dimension and then
performs a cast from one to the other. When providing type annotations, it is
good practice to start your function with a <code>dim $</code> to prevent the possibility
of type errors. For example, say we redefine velocity a different way:</p>

<pre><code>type Velocity3 = Scalar %/ Time %* Length
addVels :: Velocity1 -&gt; Velocity1 -&gt; Velocity3
addVels v1 v2 = dim $ v1 .+ v2
</code></pre>

<p>This is a bit contrived, but it demonstrates the point. Without the <code>dim</code>, the
<code>addVels</code> function would not type-check. Because <code>dim</code> needs to know its
<em>result</em> type to type-check, it should only be used at the top level, such as
here, where there is a type annotation to guide it.</p>

<p>Note that <code>dim</code> is <em>always</em> dimension-safe -- it will not convert a time to a
length!</p>

</div>
</body>
</html>
